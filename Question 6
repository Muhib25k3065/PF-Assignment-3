#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

#define DB_FILENAME "members.dat"

#define NAME_SIZE 100
#define BATCH_SIZE 32
#define MEMTYPE_SIZE 8
#define DATE_SIZE 11 
#define INTEREST_SIZE 8

typedef struct {
    int studentID;                         
    char fullName[NAME_SIZE];
    char batch[BATCH_SIZE];                
    char membershipType[MEMTYPE_SIZE];     
    char registrationDate[DATE_SIZE];      
    char dateOfBirth[DATE_SIZE];           
    char interestIn[INTEREST_SIZE];        
} Student;

void *safeMalloc(size_t bytes) {
    void *p = malloc(bytes);
    if (p == NULL) {
        fprintf(stderr, "Fatal: malloc failed for %zu bytes. Exiting.\n", bytes);
        exit(EXIT_FAILURE);
    }
    return p;
}

void *safeRealloc(void *ptr, size_t bytes) {
    void *p = realloc(ptr, bytes);
    if (p == NULL) {
        fprintf(stderr, "Fatal: realloc failed for %zu bytes. Exiting.\n", bytes);
        exit(EXIT_FAILURE);
    }
    return p;
}

void readLine(const char *prompt, char *dest, int destSize) {
    int ch;
    int i = 0;
    if (prompt) {
        printf("%s", prompt);
    }
    if (fgets(dest, destSize, stdin) == NULL) {
        dest[0] = '\0';
        return;
    }
    size_t len = strlen(dest);
    if (len > 0 && dest[len-1] == '\n') dest[len-1] = '\0';
}

void clearStdin(void) {
    int c;
    while ((c = getchar()) != '\n' && c != EOF) {}
}

Student *loadDatabase(const char *filename, int *countOut) {
    FILE *fp = fopen(filename, "rb");
    if (!fp) {
        if (errno == ENOENT) {
            *countOut = 0;
            return NULL;
        }
        fprintf(stderr, "Error opening file '%s' for reading: %s\n", filename, strerror(errno));
        *countOut = 0;
        return NULL;
    }
    
    if (fseek(fp, 0, SEEK_END) != 0) {
        fprintf(stderr, "Error seeking file: %s\n", strerror(errno));
        fclose(fp);
        *countOut = 0;
        return NULL;
    }
    long fileSize = ftell(fp);
    if (fileSize < 0) {
        fprintf(stderr, "ftell failed: %s\n", strerror(errno));
        fclose(fp);
        *countOut = 0;
        return NULL;
    }
    rewind(fp);
    
    size_t recSize = sizeof(Student);
    if (fileSize % recSize != 0) {
        fprintf(stderr, "Warning: file size not multiple of Student size; possible corruption.\n");
    }
    int count = (int)(fileSize / recSize);

    if (count == 0) {
        fclose(fp);
        *countOut = 0;
        return NULL;
    }

    Student *arr = (Student *) safeMalloc(sizeof(Student) * count);

    size_t read = fread(arr, recSize, count, fp);
    if (read != (size_t)count) {
        fprintf(stderr, "Error reading records: expected %d, got %zu\n", count, read);
        free(arr);
        fclose(fp);
        *countOut = 0;
        return NULL;
    }

    fclose(fp);
    *countOut = count;
    return arr;
}

int saveDatabase(const char *filename, Student *arr, int count) {
    FILE *fp = fopen(filename, "wb");
    if (!fp) {
        fprintf(stderr, "Error opening file '%s' for writing: %s\n", filename, strerror(errno));
        return -1;
    }

    if (count > 0) {
        size_t written = fwrite(arr, sizeof(Student), count, fp);
        if (written != (size_t)count) {
            fprintf(stderr, "Error writing records to file: wrote %zu out of %d\n", written, count);
            fclose(fp);
            return -1;
        }
    }

    fclose(fp);
    return 0;
}

int findStudentIndexByID(Student *arr, int count, int studentID) {
    int i;
    for (i = 0; i < count; i++) {
        if (arr[i].studentID == studentID) return i;
    }
    return -1;
}

void printStudent(const Student *s) {
    printf("ID: %d\n", s->studentID);
    printf("Name: %s\n", s->fullName);
    printf("Batch: %s\n", s->batch);
    printf("Membership Type: %s\n", s->membershipType);
    printf("Registration Date: %s\n", s->registrationDate);
    printf("Date of Birth: %s\n", s->dateOfBirth);
    printf("Interest In: %s\n", s->interestIn);
    printf("-----------------------------------------\n");
}

Student *appendStudentInMemory(Student *arr, int *count, int *capacity, const Student *s) {
    if (*count >= *capacity) {
        int newCap = (*capacity == 0) ? 8 : (*capacity * 2);
        arr = (Student *) safeRealloc(arr, sizeof(Student) * newCap);
        *capacity = newCap;
    }
    arr[*count] = *s;
    (*count)++;
    return arr;
}

int addStudent(Student **arrPtr, int *countPtr, int *capacityPtr, const char *filename, const Student *s) {
    Student *arr = *arrPtr;
    int count = *countPtr;
    int capacity = *capacityPtr;

    if (findStudentIndexByID(arr, count, s->studentID) != -1) {
        printf("Error: Student ID %d already exists. Aborting add.\n", s->studentID);
        return -1;
    }

    FILE *fp = fopen(filename, "ab");
    if (!fp) {
        fprintf(stderr, "Error opening file '%s' for appending: %s\n", filename, strerror(errno));
        return -1;
    }
    size_t written = fwrite(s, sizeof(Student), 1, fp);
    if (written != 1) {
        fprintf(stderr, "Error writing new student to file: %s\n", strerror(errno));
        fclose(fp);
        return -1;
    }
    fclose(fp);

    arr = appendStudentInMemory(arr, &count, &capacity, s);

    *arrPtr = arr;
    *countPtr = count;
    *capacityPtr = capacity;
    return 0;
}

int updateStudent(Student *arr, int count, int studentID, const char *filename) {
    int idx = findStudentIndexByID(arr, count, studentID);
    if (idx == -1) {
        printf("Student with ID %d not found.\n", studentID);
        return -1;
    }

    printf("Current record:\n");
    printStudent(&arr[idx]);

    printf("Update options:\n");
    printf("1) Batch (CS/SE/Cyber Security/AI)\n");
    printf("2) Membership Type (IEEE/ACM)\n");
    printf("3) Interest In (IEEE/ACM/Both)\n");
    printf("Enter choice (1-3): ");
    int choice;
    if (scanf("%d", &choice) != 1) {
        clearStdin();
        printf("Invalid input.\n");
        return -1;
    }
    clearStdin();

    if (choice == 1) {
        char newBatch[BATCH_SIZE];
        readLine("Enter new Batch: ", newBatch, BATCH_SIZE);
        strncpy(arr[idx].batch, newBatch, BATCH_SIZE-1);
        arr[idx].batch[BATCH_SIZE-1] = '\0';
    } else if (choice == 2) {
        char newType[MEMTYPE_SIZE];
        readLine("Enter Membership Type (IEEE/ACM): ", newType, MEMTYPE_SIZE);
        strncpy(arr[idx].membershipType, newType, MEMTYPE_SIZE-1);
        arr[idx].membershipType[MEMTYPE_SIZE-1] = '\0';
    } else if (choice == 3) {
        char newInterest[INTEREST_SIZE];
        readLine("Enter Interest In (IEEE/ACM/Both): ", newInterest, INTEREST_SIZE);
        strncpy(arr[idx].interestIn, newInterest, INTEREST_SIZE-1);
        arr[idx].interestIn[INTEREST_SIZE-1] = '\0';
    } else {
        printf("Invalid choice.\n");
        return -1;
    }

    if (saveDatabase(filename, arr, count) != 0) {
        fprintf(stderr, "Error saving database after update.\n");
        return -1;
    }
    printf("Record updated and saved.\n");
    return 0;
}

int deleteStudent(Student **arrPtr, int *countPtr, const char *filename, int studentID) {
    Student *arr = *arrPtr;
    int count = *countPtr;

    int idx = findStudentIndexByID(arr, count, studentID);
    if (idx == -1) {
        printf("Student with ID %d not found.\n", studentID);
        return -1;
    }

    if (idx < count - 1) {
        memmove(&arr[idx], &arr[idx+1], sizeof(Student) * (count - 1 - idx));
    }
    count--;

    if (saveDatabase(filename, arr, count) != 0) {
        fprintf(stderr, "Error saving database after delete.\n");
        return -1;
    }

    *arrPtr = arr;
    *countPtr = count;
    printf("Student ID %d deleted and changes saved.\n", studentID);
    return 0;
}

void displayAllStudents(Student *arr, int count) {
    if (count == 0) {
        printf("No records found.\n");
        return;
    }
    int i;
    for (i = 0; i < count; i++) {
        printf("Record %d:\n", i+1);
        printStudent(&arr[i]);
    }
}

void batchReport(Student *arr, int count) {
    char batchFilter[BATCH_SIZE];
    char membershipFilter[MEMTYPE_SIZE];
    readLine("Enter batch to report (CS/SE/Cyber Security/AI): ", batchFilter, BATCH_SIZE);
    readLine("Enter membership filter (IEEE/ACM/Both/All): ", membershipFilter, MEMTYPE_SIZE);

    int i;
    int found = 0;
    for (i = 0; i < count; i++) {
        int batchMatch = (strcmp(arr[i].batch, batchFilter) == 0);
        int memMatch = 0;
        if (strcmp(membershipFilter, "All") == 0 || strcmp(membershipFilter, "all") == 0) memMatch = 1;
        else if (strcmp(membershipFilter, "Both") == 0 || strcmp(membershipFilter, "both") == 0) {
            memMatch = 1;
        } else {
            memMatch = (strcmp(arr[i].membershipType, membershipFilter) == 0);
        }

        if (batchMatch && memMatch) {
            printStudent(&arr[i]);
            found = 1;
        }
    }
    if (!found) {
        printf("No matching records for batch='%s' membership='%s'\n", batchFilter, membershipFilter);
    }
}

Student inputStudentInteractive() {
    Student s;
    char buf[256];

    printf("Enter student details:\n");

    printf("Student ID (integer): ");
    while (scanf("%d", &s.studentID) != 1) {
        clearStdin();
        printf("Invalid input. Enter integer Student ID: ");
    }
    clearStdin();

    readLine("Full Name: ", s.fullName, NAME_SIZE);

    readLine("Batch (CS/SE/Cyber Security/AI): ", s.batch, BATCH_SIZE);

    readLine("Membership Type (IEEE/ACM): ", s.membershipType, MEMTYPE_SIZE);

    readLine("Registration Date (YYYY-MM-DD): ", s.registrationDate, DATE_SIZE);

    readLine("Date of Birth (YYYY-MM-DD): ", s.dateOfBirth, DATE_SIZE);

    readLine("Interest In (IEEE/ACM/Both): ", s.interestIn, INTEREST_SIZE);

    return s;
}

int main(void) {
    Student *arr = NULL;
    int count = 0;
    int capacity = 0;
    int i;

    Student *loaded = loadDatabase(DB_FILENAME, &count);
    if (loaded) {
        arr = loaded;
        capacity = count;
        if (capacity < 8) capacity = 8;
        arr = (Student *) safeRealloc(arr, sizeof(Student) * capacity);
    } else {
        capacity = 8;
        arr = (Student *) safeMalloc(sizeof(Student) * capacity);
        count = 0;
    }

    printf("IEEE/ACM Membership Registration Manager\n");
    printf("Loaded %d records from %s\n", count, DB_FILENAME);

    int running = 1;
    while (running) {
        printf("\nMenu:\n");
        printf("1) Register New Student\n");
        printf("2) Update Student (batch/membership/interest)\n");
        printf("3) Delete Student\n");
        printf("4) View All Registrations\n");
        printf("5) Generate Batch-wise Report\n");
        printf("6) Save Database Now\n");
        printf("7) Exit\n");
        printf("Enter choice: ");

        int choice;
        if (scanf("%d", &choice) != 1) {
            clearStdin();
            printf("Invalid input.\n");
            continue;
        }
        clearStdin();

        if (choice == 1) {
            Student s = inputStudentInteractive();
            int res = addStudent(&arr, &count, &capacity, DB_FILENAME, &s);
            if (res == 0) {
                printf("Student added successfully and saved to %s.\n", DB_FILENAME);
            } else {
                printf("Failed to add student.\n");
            }
        } else if (choice == 2) {
            int id;
            printf("Enter Student ID to update: ");
            if (scanf("%d", &id) != 1) {
                clearStdin();
                printf("Invalid ID.\n");
                continue;
            }
            clearStdin();
            if (updateStudent(arr, count, id, DB_FILENAME) != 0) {
                printf("Update failed or cancelled.\n");
            }
        } else if (choice == 3) {
            int id;
            printf("Enter Student ID to delete: ");
            if (scanf("%d", &id) != 1) {
                clearStdin();
                printf("Invalid ID.\n");
                continue;
            }
            clearStdin();
            if (deleteStudent(&arr, &count, DB_FILENAME, id) != 0) {
                printf("Delete failed or cancelled.\n");
            }
        } else if (choice == 4) {
            displayAllStudents(arr, count);
        } else if (choice == 5) {
            batchReport(arr, count);
        } else if (choice == 6) {
            if (saveDatabase(DB_FILENAME, arr, count) == 0) {
                printf("Database saved to %s\n", DB_FILENAME);
            } else {
                printf("Save failed.\n");
            }
        } else if (choice == 7) {
            if (saveDatabase(DB_FILENAME, arr, count) == 0) {
                printf("Database saved. Exiting...\n");
            } else {
                printf("Failed to save database. Exiting anyway...\n");
            }
            running = 0;
        } else {
            printf("Invalid menu choice.\n");
        }
    }

    free(arr);
    return 0;
}
