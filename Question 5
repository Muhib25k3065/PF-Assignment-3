#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

#define INITIAL_CAPACITY 4

typedef struct {
    char **lines;   
    int size;      
    int capacity;   
} Editor;

void *safeMalloc(size_t bytes) {
    void *p = malloc(bytes);
    if (p == NULL) {
        fprintf(stderr, "Fatal: malloc failed for %zu bytes. Exiting.\n", bytes);
        exit(EXIT_FAILURE);
    }
    return p;
}

void *safeRealloc(void *ptr, size_t bytes) {
    void *p = realloc(ptr, bytes);
    if (p == NULL) {
        fprintf(stderr, "Fatal: realloc failed for %zu bytes. Exiting.\n", bytes);
        exit(EXIT_FAILURE);
    }
    return p;
}

void initEditor(Editor *ed) {
    ed->capacity = INITIAL_CAPACITY;
    ed->size = 0;
    ed->lines = (char **) safeMalloc(sizeof(char *) * ed->capacity);

    {
        int i;
        for (i = 0; i < ed->capacity; i++) ed->lines[i] = NULL;
    }
}

void freeAll(Editor *ed) {
    int i;
    for (i = 0; i < ed->size; i++) {
        free(ed->lines[i]);
        ed->lines[i] = NULL;
    }
    free(ed->lines);
    ed->lines = NULL;
    ed->size = 0;
    ed->capacity = 0;
}

void ensureCapacity(Editor *ed) {
    if (ed->size >= ed->capacity) {
        int newCap = ed->capacity * 2;
        ed->lines = (char **) safeRealloc(ed->lines, sizeof(char *) * newCap);
        {
            int i;
            for (i = ed->capacity; i < newCap; i++) ed->lines[i] = NULL;
        }
        ed->capacity = newCap;
    }
}

void shrinkToFit(Editor *ed) {
    if (ed->capacity > ed->size) {
        if (ed->size == 0) {

            free(ed->lines);
            ed->capacity = INITIAL_CAPACITY;
            ed->lines = (char **) safeMalloc(sizeof(char *) * ed->capacity);

            {
                int i;
                for (i = 0; i < ed->capacity; i++) ed->lines[i] = NULL;
            }
        } else {
            ed->lines = (char **) safeRealloc(ed->lines, sizeof(char *) * ed->size);
            ed->capacity = ed->size;
        }
    }
}

void insertLine(Editor *ed, int index, const char *text) {
    if (index < 0 || index > ed->size) {
        fprintf(stderr, "insertLine: index %d out of range (0..%d)\n", index, ed->size);
        return;
    }

    ensureCapacity(ed);

    size_t len = strlen(text);
    char *copy = (char *) safeMalloc(len + 1);
    strcpy(copy, text);

    if (index < ed->size) {
        memmove(&ed->lines[index + 1], &ed->lines[index], sizeof(char *) * (ed->size - index));
    }

    ed->lines[index] = copy;
    ed->size++;
}

void deleteLine(Editor *ed, int index) {
    if (ed->size == 0) {
        fprintf(stderr, "deleteLine: buffer is empty\n");
        return;
    }
    if (index < 0 || index >= ed->size) {
        fprintf(stderr, "deleteLine: index %d out of range (0..%d)\n", index, ed->size - 1);
        return;
    }

    free(ed->lines[index]);  

    if (index < ed->size - 1) {
        memmove(&ed->lines[index], &ed->lines[index + 1], sizeof(char *) * (ed->size - 1 - index));
    }
    ed->lines[ed->size - 1] = NULL;
    ed->size--;
}

void printAllLines(Editor *ed) {
    int i;
    for (i = 0; i < ed->size; i++) {
        printf("%d: %s\n", i + 1, ed->lines[i]);
    }
    if (ed->size == 0) {
        printf("(buffer is empty)\n");
    }
}

int saveBuffer(Editor *ed, const char *filename) {
    FILE *fp = fopen(filename, "w");
    if (!fp) {
        fprintf(stderr, "Error opening file '%s' for writing: %s\n", filename, strerror(errno));
        return -1;
    }

    int i;
    for (i = 0; i < ed->size; i++) {
        if (fprintf(fp, "%s\n", ed->lines[i]) < 0) {
            fprintf(stderr, "Error writing to file '%s'\n", filename);
            fclose(fp);
            return -1;
        }
    }

    fclose(fp);
    return 0;
}

char *readLineFromFile(FILE *fp) {
    size_t cap = 128;
    size_t len = 0;
    char *buf = (char *) safeMalloc(cap);

    int c;
    while ((c = fgetc(fp)) != EOF) {
        if (c == '\r') {
            continue;
        }
        if (c == '\n') {
            break;
        }
        if (len + 1 >= cap) {
            cap *= 2;
            buf = (char *) safeRealloc(buf, cap);
        }
        buf[len++] = (char)c;
    }

    if (len == 0 && c == EOF) {
        free(buf);
        return NULL;
    }

    buf[len] = '\0';

    char *exact = (char *) safeMalloc(len + 1);
    strcpy(exact, buf);
    free(buf);
    return exact;
}

int loadBuffer(Editor *ed, const char *filename) {
    FILE *fp = fopen(filename, "r");
    if (!fp) {
        fprintf(stderr, "Error opening file '%s' for reading: %s\n", filename, strerror(errno));
        return -1;
    }

    {
        int i;
        for (i = 0; i < ed->size; i++) {
            free(ed->lines[i]);
            ed->lines[i] = NULL;
        }
        ed->size = 0;
    }

    char *line;
    while ((line = readLineFromFile(fp)) != NULL) {
        ensureCapacity(ed);
        ed->lines[ed->size++] = line;
    }

    fclose(fp);
    return 0;
}

char *readLineFromStdin(void) {
    size_t cap = 128;
    size_t len = 0;
    char *buf = (char *) safeMalloc(cap);

    int c;
    while ((c = getchar()) != EOF) {
        if (c == '\r') continue; 
        if (c == '\n') break;
        if (len + 1 >= cap) {
            cap *= 2;
            buf = (char *) safeRealloc(buf, cap);
        }
        buf[len++] = (char)c;
    }

    if (len == 0 && c == EOF) {
        free(buf);
        return NULL;
    }

    buf[len] = '\0';
    char *exact = (char *) safeMalloc(len + 1);
    strcpy(exact, buf);
    free(buf);
    return exact;
}

void menu(Editor *ed) {
    int running = 1;
    while (running) {
        printf("\nCommands:\n");
        printf("1) insert idx  -> insert at 0-based index\n");
        printf("2) delete idx  -> delete at index\n");
        printf("3) print       -> display all lines\n");
        printf("4) save fname  -> save to file\n");
        printf("5) load fname  -> load from file (replaces buffer)\n");
        printf("6) shrink      -> shrinkToFit\n");
        printf("7) free        -> free all and re-init buffer\n");
        printf("8) exit\n");
        printf("Enter command: ");

        char cmd[32];
        if (scanf("%31s", cmd) != 1) break;

        if (strcmp(cmd, "insert") == 0) {
            int idx;
            if (scanf("%d", &idx) != 1) {
                fprintf(stderr, "Invalid index.\n");
                int ch; while ((ch = getchar()) != '\n' && ch != EOF) {}
                continue;
            }
            int ch; while ((ch = getchar()) != '\n' && ch != EOF) {}
            printf("Enter text line: ");
            char *line = readLineFromStdin();
            if (line == NULL) {
                printf("No input read.\n");
            } else {
                insertLine(ed, idx, line);
                free(line);
            }
        }
        else if (strcmp(cmd, "delete") == 0) {
            int idx;
            if (scanf("%d", &idx) != 1) {
                fprintf(stderr, "Invalid index.\n");
                int ch; while ((ch = getchar()) != '\n' && ch != EOF) {}
                continue;
            }
            deleteLine(ed, idx);
        }
        else if (strcmp(cmd, "print") == 0) {
            printAllLines(ed);
        }
        else if (strcmp(cmd, "save") == 0) {
            char fname[256];
            if (scanf("%255s", fname) != 1) {
                fprintf(stderr, "Invalid filename.\n");
                continue;
            }
            if (saveBuffer(ed, fname) == 0) {
                printf("Saved to '%s'\n", fname);
            }
        }
        else if (strcmp(cmd, "load") == 0) {
            char fname[256];
            if (scanf("%255s", fname) != 1) {
                fprintf(stderr, "Invalid filename.\n");
                continue;
            }
            if (loadBuffer(ed, fname) == 0) {
                printf("Loaded from '%s'\n", fname);
            }
        }
        else if (strcmp(cmd, "shrink") == 0) {
            shrinkToFit(ed);
            printf("Shrink to fit done. capacity=%d size=%d\n", ed->capacity, ed->size);
        }
        else if (strcmp(cmd, "free") == 0) {
            freeAll(ed);
            initEditor(ed);
            printf("Buffer cleared and reinitialized.\n");
        }
        else if (strcmp(cmd, "exit") == 0) {
            running = 0;
        }
        else {
            printf("Unknown command '%s'\n", cmd);
            int ch; while ((ch = getchar()) != '\n' && ch != EOF) {}
        }
    }
}

int main(void) {
    Editor ed;
    initEditor(&ed);

    printf("Minimal Line-Based Text Editor Buffer (interactive)\n");
    printf("Initial capacity = %d\n", ed.capacity);

    menu(&ed);

    /* cleanup */
    freeAll(&ed);
    printf("Exiting. All memory freed.\n");
    return 0;
}
